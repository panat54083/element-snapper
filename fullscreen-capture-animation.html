<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Fullscreen Capture + Boundary Handling</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 40px 20px;
      color: #fff;
    }

    .container {
      max-width: 1200px;
      width: 100%;
    }

    h1 {
      text-align: center;
      font-size: 2.5rem;
      margin-bottom: 1rem;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
    }

    .subtitle {
      text-align: center;
      font-size: 1.2rem;
      opacity: 0.9;
      margin-bottom: 3rem;
    }

    .animation-container {
      background: #fff;
      border-radius: 20px;
      padding: 40px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
      margin-bottom: 40px;
    }

    .browser-window {
      border: 3px solid #e5e7eb;
      border-radius: 8px;
      overflow: hidden;
      background: #fff;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    }

    .browser-chrome {
      background: #f3f4f6;
      padding: 8px 12px;
      border-bottom: 1px solid #e5e7eb;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .browser-dots {
      display: flex;
      gap: 6px;
    }

    .dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #e5e7eb;
    }

    .dot.red { background: #ef4444; }
    .dot.yellow { background: #f59e0b; }
    .dot.green { background: #10b981; }

    .browser-url {
      flex: 1;
      background: #fff;
      border: 1px solid #e5e7eb;
      border-radius: 4px;
      padding: 4px 12px;
      margin-left: 12px;
      font-size: 12px;
      color: #6b7280;
    }

    .viewport-container {
      position: relative;
      height: 400px;
      overflow: hidden;
      background: #f9fafb;
    }

    .webpage {
      position: absolute;
      width: 100%;
      /* Height set by JS to simulate shorter doc */
      background: linear-gradient(180deg, #e0e7ff 0%, #dbeafe 50%, #e0f2fe 100%);
      transition: top 0.6s ease-in-out;
    }

    .target-element {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
      border: 4px solid #d97706;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      color: #78350f;
      font-size: 20px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      transition: border-color 0.3s ease;
    }

    .target-element.active {
      border-color: #dc2626;
      border-width: 5px;
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0%, 100% { box-shadow: 0 4px 12px rgba(239, 68, 68, 0.4); }
      50% { box-shadow: 0 4px 20px rgba(239, 68, 68, 0.8); }
    }

    .tile-overlay {
      position: absolute;
      border: 4px solid #10b981;
      background: rgba(16, 185, 129, 0.15);
      transition: all 0.6s ease-in-out;
      pointer-events: none;
      z-index: 10;
    }

    .discard-zone {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      background: rgba(239, 68, 68, 0.2);
      border-bottom: 2px dashed #ef4444;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #b91c1c;
      font-weight: bold;
      font-size: 14px;
      z-index: 11;
    }

    .result-canvas-container {
      margin-top: 40px;
      text-align: center;
    }

    .result-canvas-container h3 {
      color: #1f2937;
      margin-bottom: 20px;
      font-size: 1.5rem;
    }

    .stitching-container {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-top: 30px;
      flex-wrap: wrap;
    }

    .tile-preview {
      border: 2px solid #6b7280;
      border-radius: 8px;
      overflow: hidden;
      background: #f9fafb;
      opacity: 0;
      transform: scale(0.8);
      transition: all 0.4s ease;
      position: relative;
    }

    .tile-preview.visible {
      opacity: 1;
      transform: scale(1);
    }

    .tile-preview.complete {
      border-color: #10b981;
    }

    .tile-preview-label {
      background: #6b7280;
      color: white;
      padding: 4px 8px;
      font-size: 12px;
      font-weight: bold;
      text-align: center;
    }

    .controls {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-top: 30px;
    }

    button {
      background: linear-gradient(135deg, #2563eb 0%, #1e40af 100%);
      color: white;
      border: none;
      padding: 12px 32px;
      border-radius: 8px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    button:disabled { opacity: 0.5; cursor: not-allowed; }

    .status {
      text-align: center;
      margin-top: 20px;
      color: #1f2937;
      font-size: 16px;
      font-weight: 500;
      min-height: 24px;
    }

    .explanation {
      background: rgba(255, 255, 255, 0.95);
      border-radius: 12px;
      padding: 30px;
      margin-top: 40px;
      color: #1f2937;
      line-height: 1.8;
    }
    
    .explanation code {
      background: #f3f4f6;
      padding: 2px 6px;
      border-radius: 4px;
      color: #dc2626;
      font-family: monospace;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üñºÔ∏è Fullscreen Capture + Boundary Fix</h1>
    <p class="subtitle">Demonstrating what happens when the page ends before the element does</p>

    <div class="animation-container">
      <div class="browser-window">
        <div class="browser-chrome">
          <div class="browser-dots">
            <div class="dot red"></div>
            <div class="dot yellow"></div>
            <div class="dot green"></div>
          </div>
          <div class="browser-url">https://example.com/short-page-tall-element</div>
        </div>

        <div class="viewport-container" id="viewport">
          <div class="webpage" id="webpage">
            <div class="target-element" id="targetElement">
              LARGE ELEMENT<br>(1200px tall)
            </div>
            <!-- Marker for page end -->
             <div style="position: absolute; bottom: 0; width: 100%; height: 2px; background: #6b7280; text-align: right; padding-right: 10px; color: #6b7280; font-size: 12px;">End of Page</div>
          </div>
          <div class="tile-overlay" id="tileOverlay" style="display: none;">
            <div class="discard-zone" id="discardZone" style="display: none;">Overlap (Discarded)</div>
          </div>
        </div>
      </div>

      <div class="controls">
        <button id="startBtn" onclick="startAnimation()">‚ñ∂Ô∏è Start Capture</button>
        <button id="resetBtn" onclick="resetAnimation()">üîÑ Reset</button>
      </div>

      <div class="status" id="status">Ready</div>

      <div class="stitching-container" id="stitchingContainer">
        <div class="tile-preview" id="preview1">
          <div class="tile-preview-label">Tile 1 (Normal)</div>
          <canvas id="canvas1" width="150" height="100"></canvas>
        </div>
        <div class="tile-preview" id="preview2">
          <div class="tile-preview-label">Tile 2 (Normal)</div>
          <canvas id="canvas2" width="150" height="100"></canvas>
        </div>
        <div class="tile-preview" id="preview3">
          <div class="tile-preview-label" style="background:#ef4444">Tile 3 (Overlap!)</div>
          <canvas id="canvas3" width="150" height="100"></canvas>
        </div>
      </div>

      <div class="result-canvas-container" id="resultContainer" style="display: none;">
        <h3>‚úÖ Final Stitched Result</h3>
        <canvas id="finalCanvas" class="result-canvas" width="150" height="300"></canvas>
      </div>
    </div>
    
    <div class="explanation">
      <h3>The "Bottom Boundary" Problem</h3>
      <p>
        In this scenario, the element is tall (1200px), but the page ends at 1220px. 
        When we try to scroll for the <strong>3rd Tile</strong>, we hit the bottom of the page.
      </p>
      <ul>
        <li><strong>Target Scroll:</strong> 900px</li>
        <li><strong>Max Scroll:</strong> ~820px (Page Height 1220 - Viewport 400)</li>
        <li><strong>Outcome:</strong> We are forced to capture starting at 820px instead of 900px.</li>
        <li><strong>The Fix:</strong> We capture the viewport, but <em>discard the top 80px</em> (which overlaps with Tile 2) and stitch only the new content.</li>
      </ul>
    </div>
  </div>

  <script>
    const viewport = document.getElementById('viewport');
    const webpage = document.getElementById('webpage');
    const targetElement = document.getElementById('targetElement');
    const tileOverlay = document.getElementById('tileOverlay');
    const discardZone = document.getElementById('discardZone');
    const status = document.getElementById('status');
    const startBtn = document.getElementById('startBtn');
    const resetBtn = document.getElementById('resetBtn');
    const resultContainer = document.getElementById('resultContainer');
    
    // Animation Config
    const VIEWPORT_HEIGHT = 400; 
    const ELEMENT_HEIGHT = 1200; 
    const ELEMENT_WIDTH = 600; 
    const ELEMENT_TOP = 100; 
    const TILES_Y = 3;
    
    // SCENARIO: Document is just barely tall enough to contain element, but not scroll it to top
    // Element ends at 100 + 1200 = 1300.
    // Let's say Document ends at 1220.
    const DOCUMENT_HEIGHT = 1220; 
    const MAX_SCROLL = DOCUMENT_HEIGHT - VIEWPORT_HEIGHT; // 820

    // Setup DOM dimensions
    webpage.style.height = `${DOCUMENT_HEIGHT}px`;
    targetElement.style.width = `${ELEMENT_WIDTH}px`;
    targetElement.style.height = `${ELEMENT_HEIGHT}px`;
    targetElement.style.top = `${ELEMENT_TOP}px`;

    const previews = [
      document.getElementById('preview1'),
      document.getElementById('preview2'),
      document.getElementById('preview3')
    ];
    
    const canvases = [
      document.getElementById('canvas1'),
      document.getElementById('canvas2'),
      document.getElementById('canvas3')
    ];
    
    const finalCanvas = document.getElementById('finalCanvas');

    let isAnimating = false;

    function sleep(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }
    function updateStatus(msg) { status.textContent = msg; }

    function drawTileCapture(canvas, tileIndex, offset = 0) {
      const ctx = canvas.getContext('2d');
      // Background gradient
      const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
      gradient.addColorStop(0, '#fbbf24');
      gradient.addColorStop(1, '#f59e0b');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Label
      ctx.fillStyle = '#78350f';
      ctx.font = 'bold 14px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(`Tile ${tileIndex + 1}`, canvas.width / 2, canvas.height / 2);

      // Draw Offset (Discarded Zone)
      if (offset > 0) {
          // Calculate height of offset relative to canvas
          // Viewport 400px -> Canvas 100px. Scale = 0.25
          const scale = canvas.height / VIEWPORT_HEIGHT;
          const offsetH = offset * scale;

          ctx.fillStyle = 'rgba(239, 68, 68, 0.5)';
          ctx.fillRect(0, 0, canvas.width, offsetH);
          
          ctx.fillStyle = 'white';
          ctx.font = '10px sans-serif';
          ctx.fillText(`Discard`, canvas.width/2, offsetH/2);
          
          ctx.strokeStyle = '#ef4444';
          ctx.lineWidth = 2;
          ctx.strokeRect(0, 0, canvas.width, offsetH);
      }
      
      // Border
      ctx.strokeStyle = offset > 0 ? '#ef4444' : '#10b981';
      ctx.lineWidth = 3;
      ctx.strokeRect(0, 0, canvas.width, canvas.height);
    }

    function drawFinalCanvas() {
      const ctx = finalCanvas.getContext('2d');
      ctx.clearRect(0, 0, finalCanvas.width, finalCanvas.height);
      
      const tileHeight = finalCanvas.height / TILES_Y;
      
      for (let i = 0; i < TILES_Y; i++) {
        const y = i * tileHeight;
        
        // Gradient
        const gradient = ctx.createLinearGradient(0, y, 0, y + tileHeight);
        gradient.addColorStop(0, '#fbbf24');
        gradient.addColorStop(1, '#f59e0b');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, y, finalCanvas.width, tileHeight);
        
        ctx.fillStyle = '#78350f';
        ctx.font = 'bold 12px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(`Tile ${i + 1}`, finalCanvas.width / 2, y + tileHeight / 2);
        
        if (i < TILES_Y - 1) {
          ctx.strokeStyle = '#d97706';
          ctx.lineWidth = 2;
          ctx.setLineDash([5, 5]);
          ctx.beginPath();
          ctx.moveTo(0, y + tileHeight);
          ctx.lineTo(finalCanvas.width, y + tileHeight);
          ctx.stroke();
          ctx.setLineDash([]);
        }
      }
      ctx.strokeStyle = '#10b981';
      ctx.lineWidth = 3;
      ctx.strokeRect(0, 0, finalCanvas.width, finalCanvas.height);
    }

    async function startAnimation() {
      if (isAnimating) return;
      isAnimating = true;
      startBtn.disabled = true;
      resetBtn.disabled = true;
      
      resultContainer.style.display = 'none';
      previews.forEach(p => p.classList.remove('visible', 'complete'));
      
      targetElement.classList.add('active');
      updateStatus('üéØ Target identified (1200px tall)');
      await sleep(1000);
      
      tileOverlay.style.display = 'block';
      
      for (let tileY = 0; tileY < TILES_Y; tileY++) {
        // Target scroll relative to document
        const targetScrollY = ELEMENT_TOP + (tileY * VIEWPORT_HEIGHT); // 100, 500, 900
        
        // Actual scroll clamped by document height
        const actualScrollY = Math.min(targetScrollY, MAX_SCROLL);
        const scrollDiff = targetScrollY - actualScrollY; // Offset
        
        updateStatus(`üì∏ Tile ${tileY + 1}: Target ${targetScrollY}px...`);
        
        // Scroll animation
        webpage.style.top = `-${actualScrollY}px`;
        await sleep(800);

        if (scrollDiff > 0) {
           updateStatus(`‚ö†Ô∏è Hit Bottom! Actual: ${actualScrollY}px. Offset: ${scrollDiff}px`);
        }
        
        // Position Overlay
        // The tile starts at element-relative coordinate: tileY * 400.
        // Screen position = elementTop + (tileY*400) - actualScroll
        //                 = targetScrollY - actualScrollY
        // Wait, NO. 
        // We capture what is ON SCREEN.
        // We want to capture the whole viewport, but identify which part is valid.
        
        const tileHeight = Math.min(VIEWPORT_HEIGHT, ELEMENT_HEIGHT - (tileY * VIEWPORT_HEIGHT));
        
        // Overlay visualizes the "Captured Area" relative to the document
        // We are looking at VIEWPORT.
        // The Tile Target Region starts at `targetScrollY`.
        // The Viewport starts at `actualScrollY`.
        // So the Tile Target Region starts at `targetScrollY - actualScrollY` inside the viewport.
        const overlayTopInViewport = targetScrollY - actualScrollY; 
        
        tileOverlay.style.top = '0px'; 
        tileOverlay.style.height = '400px'; // Showing full capture
        // Correction: Let's make the overlay show the VALID part green, and Discard red.
        
        // Only visual adjustment:
        tileOverlay.style.top = '0px'; // Relative to viewport container
        tileOverlay.style.height = `${VIEWPORT_HEIGHT}px`;
        tileOverlay.style.left = '50%';
        tileOverlay.style.transform = 'translateX(-50%)';
        tileOverlay.style.width = `${ELEMENT_WIDTH + 40}px`; // slightly wider

        if (scrollDiff > 0) {
          discardZone.style.display = 'flex';
          discardZone.style.height = `${scrollDiff}px`;
          tileOverlay.style.borderColor = '#ef4444';
          tileOverlay.innerHTML = `<div class="discard-zone" style="height:${scrollDiff}px">Overlap: ${scrollDiff}px</div>`;
        } else {
          discardZone.style.display = 'none';
          tileOverlay.style.borderColor = '#10b981';
          tileOverlay.innerHTML = `<div class="tile-label">Attributes OK</div>`;
        }

        await sleep(1000);
        
        // Preview
        previews[tileY].classList.add('visible');
        drawTileCapture(canvases[tileY], tileY, scrollDiff);
        
        if(scrollDiff > 0) updateStatus(`‚úÇÔ∏è Cropping top ${scrollDiff}px...`);
        else updateStatus(`‚úÖ Captured Tile ${tileY+1}`);
        
        await sleep(800);
        previews[tileY].classList.add('complete');
      }
      
      tileOverlay.style.display = 'none';
      webpage.style.top = '0px';
      
      updateStatus('‚ú® Stitching (discarding overlaps)... Done!');
      await sleep(500);
      drawFinalCanvas();
      resultContainer.style.display = 'block';
      
      isAnimating = false;
      startBtn.disabled = false;
      resetBtn.disabled = false;
    }

    function resetAnimation() {
      if (isAnimating) return;
      webpage.style.top = '0px';
      tileOverlay.style.display = 'none';
      targetElement.classList.remove('active');
      resultContainer.style.display = 'none';
      status.textContent = 'Ready';
      previews.forEach(p => p.classList.remove('visible', 'complete'));
      canvases.forEach(c => c.getContext('2d').clearRect(0,0,150,100));
      finalCanvas.getContext('2d').clearRect(0,0,150,300);
    }
    
    // Initial paint
    resetAnimation();
  </script>
</body>
</html>
